\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}     % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ...
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent

% \VignetteIndexEntry{An R Package for determining differential abundance in high throughput sequencing experiments}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{wrapfig}
\usepackage[margin=1in,font=small,labelfont=bf,
               labelsep=colon]{caption}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}



\title{CoDaSeq: Compositional Data Analysis tools for high throughput sequencing}
\author{Greg Gloor}
\date{\today}                                           % Activate to display a given date or no date

\usepackage{Sweave}
\begin{document}

\maketitle
\tableofcontents
%\listoffigures
%\listoftables
\section{What is CoDaSeq?}
CoDaSeq is a suite of tools for the exploratory and analytical analysis of high throughput DNA sequencing data in a compositional data analysis (CoDa) framework. Many high throughput sequencing approaches generate similar data: reads are mapped to features in each sample, these features are normalized, then exploratory data analysis and statistical analysis is performed. CoDaSeq provides a simple consistent framework for data analysis that encompasses many different experimental designs by modelling the data as centre-log ratio transformed values rather than normalized counts or as proportions or relative abundances.

CoDaSeq provides a number of functions for the exploration and display of these data and builds upon a number of other R packages for compositional data analysis.

\section{Introduction}

\section{Installation}
Download and install the most current of CoDaSeq. It has been tested with version R version 3, but should run on version 2.12 onward. ALDEx2 will make use of the BiocParallel package if possible, otherwise, ALDEx2 will run in serial mode.

\section{Exploratory data analysis example of a 16S rRNA gene sequencing experiment using the `ak\_op' example data}

The ak\_op dataset is a small subset of the HMP oral microbiome dataset samples, with 15 samples from the attached keratinized gingiva and 15 samples from the external tooth plaque. These data are used as an example because they are extraordinarily sparse and represent a worst-case scenario for dealing with sparsity. The user is encouraged to try different filtering parameters to explore how filtering by abundance or sparsity affects the results.

First we load the library and the data and filter it by abundance.

\begin{Schunk}
\begin{Sinput}
> library(CoDaSeq)
> library(zCompositions)
> data(ak_op)
> data(hmpgenera)
> # the first function is to subset the dataselex
> f <- codaSeq.filter(ak_op, min.reads=1000, min.prop=0.01, max.prop=1,
+     min.occurrence=0.25, samples.by.row=FALSE)
> 
> # this should leave 167 OTUs and 30 samples
\end{Sinput}
\end{Schunk}

CoDaSeq contains several different ways to filter datasets.

\begin{description}
\item[min.reads] Sample-based filter to keep only samples with a minimum number of reads
\item[min.prop] OTU-based filter to keep only OTUs that have a proportional abundance greater than the cutoff in any sample. Values range from 0-1. Use 0 to keep all OTUs that have at least one read in any sample.
\item[max.prop] OTU-based filter to keep only OTUS that have a proportional abundance less than the cutoff in any sample. Values range from 0-1.
\item[min.occurrence] OTU-based filter to keep OTUs that occur in at least the given proportion of samples. Values range from 0-1.
\item[samples.by.row] TRUE if data is arranged with samples in rows and OTUs in columns. FALSE if data is arranged with samples in columns and OTUs in rows.
\end{description}

We now replace 0 counts in the dataset with imputed values using the Count Zero multiplicative method instantiated in the zCompositions package. This approach replaces 0 values in count compositional datasets while retaining the relationships between the remaining values. This is the most principled method for adding a pseudo count to the dataset, but in most cases adding a uniform pseudo count, or a uniform prior to the data will, in general, not have large effects unless unreasonable values are chosen.

\begin{Schunk}
\begin{Sinput}
> # replace 0 values with an imputed value using the Count Zero Multiplicative method
> # from the zCompositions package
> # the table is transposed t() to make the samples by row
> # all further analyses have this orientation
> f.n0 <- cmultRepl(t(f), label=0, method="CZM")
> # perform the centered log-ratio transformation
> f.clr <- codaSeq.clr(f.n0, samples.by.row=TRUE)
\end{Sinput}
\end{Schunk}

this is junk

\begin{figure}\label{biplot}
\begin{center}
\begin{Schunk}
\begin{Sinput}
> # perform the singular value decomposition on clr transformed values
> f.pcx <- prcomp(f.clr)
> biplot(f.pcx, var.axes=FALSE, cex=c(0.5,0.6), scale=0)
\end{Sinput}
\end{Schunk}
\end{center}
\end{figure}
\newpage

\subsection{Stripcharts}

\begin{figure}\label{strip chart}
\begin{center}
\begin{Schunk}
\begin{Sinput}
> # perform the singular value decomposition on clr transformed values
> conds <- c(rep("A", 15), rep("O", 15))
> f.x <- aldex.clr(f, conds)
\end{Sinput}
\begin{Soutput}
[1] "operating in serial mode"
[1] "Computing center with all features."
\end{Soutput}
\begin{Sinput}
> f.e <- aldex.effect(f.x, conds)
\end{Sinput}
\begin{Soutput}
[1] "operating in serial mode"
[1] "sanity check complete"
[1] "rab.all  complete"
[1] "rab.win  complete"
[1] "rab of samples complete"
[1] "within sample difference calculated"
[1] "between group difference calculated"
[1] "group summaries calculated"
[1] "effect size calculated"
[1] "summarizing output"
\end{Soutput}
\begin{Sinput}
> f.t <- aldex.ttest(f.x, conds)
> f.all <- data.frame(f.e,f.t)
> codaSeq.stripchart(aldex.out=f.all, group.table=hmpgenera, group.label="genus", 
+     p.cutoff=0.05, x.axis="effect")